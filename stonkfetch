#!/usr/bin/env python3

import argparse
import sys
import json
import re
import time
import signal
from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError
from datetime import datetime
from typing import Dict, Optional, Tuple, List
from io import BytesIO

try:
    from PIL import Image
    HAS_PIL = True
except ImportError:
    HAS_PIL = False

_ANSI_ESCAPE = re.compile(r'\033\[[0-9;]*m')

# Constants
_ASCII_ASPECT_RATIO = 0.55
_LUMINANCE_R = 0.299
_LUMINANCE_G = 0.587
_LUMINANCE_B = 0.114
_REQUEST_TIMEOUT = 10
_LOGO_TIMEOUT = 5


class ColorMapper:
    @staticmethod
    def rgb_to_ansi256(r: int, g: int, b: int) -> int:
        if r == g == b:
            if r < 8:
                return 16
            if r > 248:
                return 231
            return 232 + ((r - 8) // 10)

        r_level = (r * 6) // 256
        g_level = (g * 6) // 256
        b_level = (b * 6) // 256
        return 16 + (36 * r_level) + (6 * g_level) + b_level

    @staticmethod
    def get_ansi_color_code(r: int, g: int, b: int, foreground: bool = True) -> str:
        ansi_code = ColorMapper.rgb_to_ansi256(r, g, b)
        prefix = "38" if foreground else "48"
        return f"\033[{prefix};5;{ansi_code}m"


class ASCIIGenerator:
    ASCII_CHARS = ["@", "#", "S", "%", "?", "*", "+", ";", ":", ",", "."]

    @staticmethod
    def image_to_ascii_colored(
        image_data: bytes,
        width: int = 40,
        colored: bool = True
    ) -> List[str]:
        if not HAS_PIL:
            return []

        try:
            img = Image.open(BytesIO(image_data))
            if img.mode != 'RGB':
                img = img.convert('RGB')

            original_width, original_height = img.size
            aspect_ratio = original_height / original_width
            new_height = int(width * aspect_ratio * _ASCII_ASPECT_RATIO)

            img_resized = img.resize((width, new_height))
            rgb_pixels = list(img_resized.getdata())

            chars = ASCIIGenerator.ASCII_CHARS
            step = max(1, 256 // len(chars))
            reset_code = "\033[0m" if colored else ""

            ascii_lines = []
            for row in range(new_height):
                line_parts = []
                for col in range(width):
                    idx = row * width + col
                    r, g, b = rgb_pixels[idx]
                    gray_val = int(_LUMINANCE_R * r + _LUMINANCE_G * g + _LUMINANCE_B * b)
                    char_index = min(len(chars) - 1, gray_val // step)
                    char = chars[char_index]

                    if colored:
                        color_code = ColorMapper.get_ansi_color_code(r, g, b)
                        line_parts.append(f"{color_code}{char}{reset_code}")
                    else:
                        line_parts.append(char)

                ascii_lines.append("".join(line_parts))

            return ascii_lines
        except Exception as e:
            print(f"Error converting image to ASCII: {e}", file=sys.stderr)
            return []


class LogoFetcher:
    LOGO_SOURCES = [
        {'name': 'Clearbit', 'url_template': 'https://logo.clearbit.com/{domain}'},
        {'name': 'UpLead',   'url_template': 'https://logo.uplead.com/{domain}'},
    ]

    _DOMAIN_MAP = {
        'AAPL': 'apple.com',
        'MSFT': 'microsoft.com',
        'GOOGL': 'google.com',
        'GOOG': 'google.com',
        'AMZN': 'amazon.com',
        'META': 'meta.com',
        'TSLA': 'tesla.com',
        'NVDA': 'nvidia.com',
        'JPM': 'jpmorganchase.com',
        'V': 'visa.com',
        'WMT': 'walmart.com',
        'DIS': 'disney.com',
        'MA': 'mastercard.com',
        'NFLX': 'netflix.com',
        'PYPL': 'paypal.com',
        'INTC': 'intel.com',
        'CSCO': 'cisco.com',
        'ADBE': 'adobe.com',
        'CRM': 'salesforce.com',
        'NKE': 'nike.com',
        'PFE': 'pfizer.com',
        'KO': 'coca-cola.com',
        'PEP': 'pepsi.com',
        'MCD': 'mcdonalds.com',
        'BA': 'boeing.com',
        'IBM': 'ibm.com',
        'ORCL': 'oracle.com',
        'AMD': 'amd.com',
        'QCOM': 'qualcomm.com',
        'TXN': 'ti.com',
        'SBUX': 'starbucks.com',
        'T': 'att.com',
        'VZ': 'verizon.com',
        'GM': 'gm.com',
        'F': 'ford.com',
        'GE': 'ge.com',
        'CAT': 'caterpillar.com',
        'UBER': 'uber.com',
        'LYFT': 'lyft.com',
        'SNAP': 'snap.com',
        'SPOT': 'spotify.com',
        'SQ': 'squareup.com',
        'SHOP': 'shopify.com',
        'ZM': 'zoom.us',
        'DOCU': 'docusign.com',
        'NOW': 'servicenow.com',
        'SNOW': 'snowflake.com',
        'CRWD': 'crowdstrike.com',
        'PANW': 'paloaltonetworks.com',
        'ABNB': 'airbnb.com',
        'COIN': 'coinbase.com',
        'RBLX': 'roblox.com',
        'U': 'unity.com',
        'DDOG': 'datadoghq.com',
        'NET': 'cloudflare.com',
    }

    @staticmethod
    def get_company_domain(symbol: str, company_name: str) -> Optional[str]:
        symbol_upper = symbol.upper()
        if symbol_upper in LogoFetcher._DOMAIN_MAP:
            return LogoFetcher._DOMAIN_MAP[symbol_upper]

        if company_name and company_name != 'N/A':
            name_parts = company_name.lower().split()
            if name_parts:
                first_word = name_parts[0].strip('.,')
                if first_word not in ['the', 'inc', 'corp', 'ltd', 'llc', 'co']:
                    return f"{first_word}.com"

        return None

    @staticmethod
    def fetch_logo(symbol: str, company_name: str) -> Optional[bytes]:
        domain = LogoFetcher.get_company_domain(symbol, company_name)
        if not domain:
            return None

        for source in LogoFetcher.LOGO_SOURCES:
            try:
                url = source['url_template'].format(domain=domain)
                headers = {
                    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
                }
                req = Request(url, headers=headers)
                with urlopen(req, timeout=_LOGO_TIMEOUT) as response:
                    if response.status == 200:
                        return response.read()
            except (URLError, HTTPError):
                continue

        return None


class stonkfetch:
    COLORS = {
        'reset': '\033[0m',
        'bold': '\033[1m',
        'green': '\033[92m',
        'red': '\033[91m',
        'yellow': '\033[93m',
        'blue': '\033[94m',
        'magenta': '\033[95m',
        'cyan': '\033[96m',
        'white': '\033[97m',
    }

    def __init__(
        self,
        symbol: str,
        no_color: bool = False,
        no_logo: bool = False,
        ascii_width: int = 40,
        colored_ascii: bool = True
    ):
        self.symbol = symbol.upper()
        self.no_color = no_color
        self.no_logo = no_logo
        self.ascii_width = ascii_width
        self.colored_ascii = colored_ascii and not no_color
        self.data: Optional[Dict] = None
        self.ascii_art: List[str] = []

    def _colorize(self, text: str, color: str) -> str:
        if self.no_color:
            return text
        color_code = self.COLORS.get(color, '')
        reset_code = self.COLORS['reset']
        return f"{color_code}{text}{reset_code}"

    def _fetch_data(self) -> bool:
        try:
            base_url = "https://query1.finance.yahoo.com/v8/finance/chart/"
            url = f"{base_url}{self.symbol}?interval=1d&range=5d"
            headers = {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
            }
            req = Request(url, headers=headers)
            with urlopen(req, timeout=_REQUEST_TIMEOUT) as response:
                data = json.loads(response.read().decode())

            if 'chart' not in data or 'result' not in data['chart']:
                return False

            result = data['chart']['result'][0]
            meta = result.get('meta', {})
            quote = result.get('indicators', {}).get('quote', [{}])[0]
            timestamps = result.get('timestamp', [])

            if not timestamps or not quote.get('close'):
                return False

            close_prices = quote.get('close', [])
            volumes = quote.get('volume', [])
            opens = quote.get('open', [])
            highs = quote.get('high', [])
            lows = quote.get('low', [])

            latest_idx = len(close_prices) - 1
            while latest_idx >= 0 and close_prices[latest_idx] is None:
                latest_idx -= 1
            if latest_idx < 0:
                return False

            prev_idx = latest_idx - 1
            while prev_idx >= 0 and close_prices[prev_idx] is None:
                prev_idx -= 1

            current_price = close_prices[latest_idx]
            previous_close = close_prices[prev_idx] if prev_idx >= 0 else meta.get('previousClose', current_price)

            self.data = {
                'symbol': meta.get('symbol', self.symbol),
                'name': meta.get('longName') or meta.get('shortName', 'N/A'),
                'currency': meta.get('currency', 'USD'),
                'exchange': meta.get('exchangeName', 'N/A'),
                'current_price': current_price,
                'previous_close': previous_close,
                'open': opens[latest_idx] if opens and opens[latest_idx] else None,
                'high': highs[latest_idx] if highs and highs[latest_idx] else None,
                'low': lows[latest_idx] if lows and lows[latest_idx] else None,
                'volume': volumes[latest_idx] if volumes and volumes[latest_idx] else None,
                'market_cap': meta.get('marketCap'),
                'fifty_two_week_high': meta.get('fiftyTwoWeekHigh'),
                'fifty_two_week_low': meta.get('fiftyTwoWeekLow'),
                'timestamp': timestamps[latest_idx] if timestamps else None,
            }
            return True
        except (URLError, HTTPError, json.JSONDecodeError, KeyError, IndexError) as e:
            print(f"Error fetching data: {e}", file=sys.stderr)
            return False

    def _generate_ascii_art(self) -> None:
        if self.no_logo or not HAS_PIL:
            if not HAS_PIL and not self.no_logo:
                print("Note: PIL/Pillow not installed. Proceeding without logo ASCII art.", file=sys.stderr)
            self.ascii_art = []
            return

        company_name = self.data.get('name', '') if self.data else ''
        logo_data = LogoFetcher.fetch_logo(self.symbol, company_name)
        if logo_data:
            ascii_lines = ASCIIGenerator.image_to_ascii_colored(
                logo_data,
                width=self.ascii_width,
                colored=self.colored_ascii
            )
            if ascii_lines:
                self.ascii_art = ascii_lines
                return

        self.ascii_art = []

    def _format_number(self, num: Optional[float], decimals: int = 2) -> str:
        if num is None:
            return "N/A"
        if abs(num) >= 1_000_000_000:
            return f"{num / 1_000_000_000:.{decimals}f}B"
        elif abs(num) >= 1_000_000:
            return f"{num / 1_000_000:.{decimals}f}M"
        elif abs(num) >= 1_000:
            return f"{num / 1_000:.{decimals}f}K"
        else:
            return f"{num:.{decimals}f}"

    def _format_price(self, price: Optional[float]) -> str:
        if price is None:
            return "N/A"
        currency_symbol = "$" if self.data['currency'] == "USD" else self.data['currency']
        return f"{currency_symbol}{price:.2f}"

    def _get_change_info(self) -> Tuple[float, float, str]:
        if not self.data:
            return 0.0, 0.0, 'white'
        current = self.data.get('current_price', 0)
        previous = self.data.get('previous_close', current)
        change = current - previous
        pct_change = (change / previous * 100) if previous else 0
        color = 'green' if change > 0 else 'red' if change < 0 else 'white'
        return change, pct_change, color

    def _strip_ansi(self, text: str) -> str:
        return _ANSI_ESCAPE.sub('', text)

    def _clear_screen(self) -> None:
        print("\033[2J\033[H", end="")

    def _build_info_lines(self) -> List[str]:
        change, pct_change, change_color = self._get_change_info()
        change_symbol = "▲" if change > 0 else "▼" if change < 0 else "●"

        info_lines = [
            f"{self._colorize(self.data['symbol'], 'bold')}@{self._colorize(self.data['exchange'], 'bold')}",
            "─" * (len(self.data['symbol']) + len(self.data['exchange']) + 1),
            f"{self._colorize('Name:', 'cyan')} {self.data['name'][:50]}",
            f"{self._colorize('Price:', 'yellow')} {self._format_price(self.data['current_price'])}",
            f"{self._colorize('Change:', change_color)} {change_symbol} {self._format_price(abs(change))} ({abs(pct_change):.2f}%)",
            f"{self._colorize('Open:', 'blue')} {self._format_price(self.data['open'])}",
            f"{self._colorize('High:', 'green')} {self._format_price(self.data['high'])}",
            f"{self._colorize('Low:', 'red')} {self._format_price(self.data['low'])}",
            f"{self._colorize('Volume:', 'magenta')} {self._format_number(self.data['volume'], 1)}",
        ]

        if self.data.get('market_cap'):
            info_lines.append(
                f"{self._colorize('Market Cap:', 'cyan')} {self._format_number(self.data['market_cap'], 2)}"
            )

        if self.data.get('fifty_two_week_high'):
            info_lines.append(
                f"{self._colorize('52W High:', 'green')} {self._format_price(self.data['fifty_two_week_high'])}"
            )

        if self.data.get('fifty_two_week_low'):
            info_lines.append(
                f"{self._colorize('52W Low:', 'red')} {self._format_price(self.data['fifty_two_week_low'])}"
            )

        if self.data.get('timestamp'):
            dt = datetime.fromtimestamp(self.data['timestamp'])
            info_lines.append(f"{self._colorize('Updated:', 'white')} {dt.strftime('%Y-%m-%d %H:%M:%S')}")

        return info_lines

    def _render_output(self, info_lines: List[str]) -> None:
        max_lines = max(len(self.ascii_art), len(info_lines))
        stripped_ascii = [self._strip_ansi(line) for line in self.ascii_art] if self.ascii_art else []
        ascii_width = max(len(line) for line in stripped_ascii) if stripped_ascii else 0

        print()
        for i in range(max_lines):
            ascii_part = self.ascii_art[i] if i < len(self.ascii_art) else ""
            info_part = info_lines[i] if i < len(info_lines) else ""

            actual_width = len(stripped_ascii[i]) if i < len(stripped_ascii) else 0
            padding = " " * (ascii_width - actual_width + 4 if ascii_width >= actual_width else 4)
            print(f"{ascii_part}{padding}{info_part}")
        print()

    def display(self, clear_screen: bool = False, exit_on_error: bool = True) -> bool:
        if not self._fetch_data() or not self.data:
            error_msg = f"Error: Could not fetch data for symbol '{self.symbol}'"
            print(error_msg, file=sys.stderr)
            if exit_on_error:
                sys.exit(1)
            return False

        if clear_screen:
            self._clear_screen()

        self._generate_ascii_art()
        info_lines = self._build_info_lines()
        self._render_output(info_lines)
        return True

    def watch(self, interval: int) -> None:
        interrupted = False

        def signal_handler(signum, frame):
            nonlocal interrupted
            interrupted = True

        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)

        print("\033[?25l", end="")

        try:
            while not interrupted:
                try:
                    success = self.display(clear_screen=True, exit_on_error=False)
                    if not success and not interrupted:
                        time.sleep(interval)
                        continue
                except Exception as e:
                    print(f"Error during update: {e}", file=sys.stderr)
                    if not interrupted:
                        time.sleep(interval)
                    continue

                if not interrupted:
                    time.sleep(interval)

        except KeyboardInterrupt:
            pass
        finally:
            print("\033[?25h", end="")
            print()


def main():
    parser = argparse.ArgumentParser(
        description='stonkfetch - Display stock information with colored logo ASCII art',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
stonkfetch AAPL                       Display with colored logo
stonkfetch TSLA --no-color-ascii      Grayscale ASCII art
stonkfetch MSFT --no-logo             Use fallback ASCII
stonkfetch GOOGL --ascii-width 50     Custom width
stonkfetch AMZN --no-color            Disable all colors
stonkfetch AAPL --watch 5             Update every 5 seconds
        """
    )

    parser.add_argument(
        'symbol',
        type=str,
        help='Stock ticker symbol (e.g., AAPL, TSLA, MSFT)'
    )

    parser.add_argument(
        '--no-color',
        action='store_true',
        help='Disable all colored output (ASCII and text)'
    )

    parser.add_argument(
        '--no-color-ascii',
        action='store_true',
        help='Disable colors in ASCII art only (keep text colors)'
    )

    parser.add_argument(
        '--no-logo',
        action='store_true',
        help='Disable logo fetching and use info-only view'
    )

    parser.add_argument(
        '--ascii-width',
        type=int,
        default=40,
        help='Width of ASCII art in characters (default: 40)'
    )

    parser.add_argument(
        '--watch',
        type=int,
        metavar='SECONDS',
        help='Continuously update display every SECONDS (e.g., --watch 5 for 5-second updates). Press Ctrl+C to exit.'
    )

    parser.add_argument(
        '--version',
        action='version',
        version='stonkfetch 1.2'
    )

    args = parser.parse_args()
    colored_ascii = not args.no_color_ascii and not args.no_color

    if args.watch is not None and args.watch < 1:
        print("Error: Watch interval must be at least 1 second", file=sys.stderr)
        sys.exit(1)

    fetcher = stonkfetch(
        args.symbol,
        no_color=args.no_color,
        no_logo=args.no_logo,
        ascii_width=args.ascii_width,
        colored_ascii=colored_ascii
    )

    if args.watch is not None:
        fetcher.watch(args.watch)
    else:
        fetcher.display()


if __name__ == "__main__":
    main()
