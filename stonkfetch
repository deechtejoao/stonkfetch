#!/usr/bin/env python3

import argparse
import sys
import json
import re
from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError
from datetime import datetime
from typing import Dict, Optional, Tuple, List
from io import BytesIO

try:
    from PIL import Image
    HAS_PIL = True
except ImportError:
    HAS_PIL = False

class ColorMapper:
    @staticmethod
    def rgb_to_ansi256(r: int, g: int, b: int) -> int:
        
        if r == g == b:
            if r < 8:
                return 16
            if r > 248:
                return 231
            return 232 + ((r - 8) // 10)

        r_level = (r * 6) // 256
        g_level = (g * 6) // 256
        b_level = (b * 6) // 256
        return 16 + (36 * r_level) + (6 * g_level) + b_level

    @staticmethod
    def get_ansi_color_code(r: int, g: int, b: int, foreground: bool = True) -> str:
        
        ansi_code = ColorMapper.rgb_to_ansi256(r, g, b)
        prefix = "38" if foreground else "48"
        return f"\033[{prefix};5;{ansi_code}m"

    @staticmethod
    def get_dominant_color(img: 'Image.Image') -> Tuple[int, int, int]:
        
        img_small = img.resize((50, 50))
        if img_small.mode != 'RGB':
            img_small = img_small.convert('RGB')

        pixels = list(img_small.getdata())
        r_avg = sum(p[0] for p in pixels) // len(pixels)
        g_avg = sum(p[1] for p in pixels) // len(pixels)
        b_avg = sum(p[2] for p in pixels) // len(pixels)
        return (r_avg, g_avg, b_avg)


class ASCIIGenerator:

    ASCII_CHARS = ["@", "#", "S", "%", "?", "*", "+", ";", ":", ",", "."]
    ASCII_CHARS_DETAILED = ["@", "#", "S", "%", "?", "*", "+", ";", ":", ",", ".", " "]

    @staticmethod
    def image_to_ascii_colored(
        image_data: bytes,
        width: int = 40,
        detailed: bool = False,
        colored: bool = True
    ) -> List[str]:
        
        if not HAS_PIL:
            return []

        try:
            img = Image.open(BytesIO(image_data))
            if img.mode != 'RGB':
                img = img.convert('RGB')

            original_width, original_height = img.size
            aspect_ratio = original_height / original_width
            new_height = int(width * aspect_ratio * 0.55)

            img_resized = img.resize((width, new_height))
            rgb_pixels = list(img_resized.getdata())

            img_gray = img_resized.convert('L')
            gray_pixels = list(img_gray.getdata())

            chars = ASCIIGenerator.ASCII_CHARS_DETAILED if detailed else ASCIIGenerator.ASCII_CHARS
            ascii_lines = []
            reset_code = "\033[0m"

            for row in range(new_height):
                line = ""
                for col in range(width):
                    idx = row * width + col
                    gray_val = gray_pixels[idx]
                    char_index = min(len(chars) - 1, gray_val // (256 // len(chars)))
                    char = chars[char_index]

                    if colored:
                        r, g, b = rgb_pixels[idx]
                        color_code = ColorMapper.get_ansi_color_code(r, g, b)
                        line += f"{color_code}{char}{reset_code}"
                    else:
                        line += char

                ascii_lines.append(line)

            return ascii_lines
        except Exception as e:
            print(f"Error converting image to ASCII: {e}", file=sys.stderr)
            return []

    @staticmethod
    def get_fallback_ascii(symbol: str, color: Optional[str] = None) -> List[str]:
        
        colors = {
            'cyan': '\033[96m',
            'green': '\033[92m',
            'yellow': '\033[93m',
            'blue': '\033[94m',
            'magenta': '\033[95m',
            'red': '\033[91m',
            'reset': '\033[0m'
        }

        c = colors.get(color, '') if color else ''
        r = colors['reset'] if color else ''

        return [
                ""
        ]


class LogoFetcher:
    LOGO_SOURCES = [
        {
            'name': 'Clearbit',
            'url_template': 'https://logo.clearbit.com/{domain}',
            'requires_domain': True
        },
        {
            'name': 'UpLead',
            'url_template': 'https://logo.uplead.com/{domain}',
            'requires_domain': True
        }
    ]

    @staticmethod
    def get_company_domain(symbol: str, company_name: str) -> Optional[str]:
        domain_map = {
            'AAPL': 'apple.com',
            'MSFT': 'microsoft.com',
            'GOOGL': 'google.com',
            'GOOG': 'google.com',
            'AMZN': 'amazon.com',
            'META': 'meta.com',
            'TSLA': 'tesla.com',
            'NVDA': 'nvidia.com',
            'JPM': 'jpmorganchase.com',
            'V': 'visa.com',
            'WMT': 'walmart.com',
            'DIS': 'disney.com',
            'MA': 'mastercard.com',
            'NFLX': 'netflix.com',
            'PYPL': 'paypal.com',
            'INTC': 'intel.com',
            'CSCO': 'cisco.com',
            'ADBE': 'adobe.com',
            'CRM': 'salesforce.com',
            'NKE': 'nike.com',
            'PFE': 'pfizer.com',
            'KO': 'coca-cola.com',
            'PEP': 'pepsi.com',
            'MCD': 'mcdonalds.com',
            'BA': 'boeing.com',
            'IBM': 'ibm.com',
            'ORCL': 'oracle.com',
            'AMD': 'amd.com',
            'QCOM': 'qualcomm.com',
            'TXN': 'ti.com',
            'SBUX': 'starbucks.com',
            'T': 'att.com',
            'VZ': 'verizon.com',
            'GM': 'gm.com',
            'F': 'ford.com',
            'GE': 'ge.com',
            'CAT': 'caterpillar.com',
            'UBER': 'uber.com',
            'LYFT': 'lyft.com',
            'SNAP': 'snap.com',
            'SPOT': 'spotify.com',
            'SQ': 'squareup.com',
            'SHOP': 'shopify.com',
            'ZM': 'zoom.us',
            'DOCU': 'docusign.com',
            'NOW': 'servicenow.com',
            'SNOW': 'snowflake.com',
            'CRWD': 'crowdstrike.com',
            'PANW': 'paloaltonetworks.com',
            'ABNB': 'airbnb.com',
            'COIN': 'coinbase.com',
            'RBLX': 'roblox.com',
            'U': 'unity.com',
            'DDOG': 'datadoghq.com',
            'NET': 'cloudflare.com',
        }

        if symbol.upper() in domain_map:
            return domain_map[symbol.upper()]

        if company_name and company_name != 'N/A':
            name_parts = company_name.lower().split()
            if name_parts:
                first_word = name_parts[0].strip('.,')
                if first_word not in ['the', 'inc', 'corp', 'ltd', 'llc', 'co']:
                    return f"{first_word}.com"

        return None

    @staticmethod
    def fetch_logo(symbol: str, company_name: str) -> Optional[bytes]:
        
        domain = LogoFetcher.get_company_domain(symbol, company_name)
        if not domain:
            return None

        for source in LogoFetcher.LOGO_SOURCES:
            try:
                url = source['url_template'].format(domain=domain)
                headers = {
                    'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
                }

                req = Request(url, headers=headers)
                with urlopen(req, timeout=5) as response:
                    if response.status == 200:
                        return response.read()
            except (URLError, HTTPError):
                continue

        return None


class stonkfetch:

    COLORS = {
        'reset': '\033[0m',
        'bold': '\033[1m',
        'green': '\033[92m',
        'red': '\033[91m',
        'yellow': '\033[93m',
        'blue': '\033[94m',
        'magenta': '\033[95m',
        'cyan': '\033[96m',
        'white': '\033[97m',
    }

    def __init__(
        self,
        symbol: str,
        no_color: bool = False,
        no_logo: bool = False,
        ascii_width: int = 40,
        colored_ascii: bool = True
    ):
        self.symbol = symbol.upper()
        self.no_color = no_color
        self.no_logo = no_logo
        self.ascii_width = ascii_width
        self.colored_ascii = colored_ascii and not no_color
        self.data: Optional[Dict] = None
        self.ascii_art: List[str] = []

    def _colorize(self, text: str, color: str) -> str:
        
        if self.no_color:
            return text
        return f"{self.COLORS.get(color, '')}{text}{self.COLORS['reset']}"

    def _fetch_data(self) -> bool:
        
        try:
            base_url = "https://query1.finance.yahoo.com/v8/finance/chart/"
            url = f"{base_url}{self.symbol}?interval=1d&range=5d"
            headers = {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
            }

            req = Request(url, headers=headers)
            with urlopen(req, timeout=10) as response:
                data = json.loads(response.read().decode())

            if 'chart' not in data or 'result' not in data['chart']:
                return False

            result = data['chart']['result'][0]
            meta = result.get('meta', {})
            quote = result.get('indicators', {}).get('quote', [{}])[0]
            timestamps = result.get('timestamp', [])

            if not timestamps or not quote.get('close'):
                return False

            close_prices = quote.get('close', [])
            volumes = quote.get('volume', [])
            opens = quote.get('open', [])
            highs = quote.get('high', [])
            lows = quote.get('low', [])

            latest_idx = len(close_prices) - 1
            while latest_idx >= 0 and close_prices[latest_idx] is None:
                latest_idx -= 1

            if latest_idx < 0:
                return False

            prev_idx = latest_idx - 1
            while prev_idx >= 0 and close_prices[prev_idx] is None:
                prev_idx -= 1

            current_price = close_prices[latest_idx]
            previous_close = close_prices[prev_idx] if prev_idx >= 0 else meta.get('previousClose', current_price)

            self.data = {
                'symbol': meta.get('symbol', self.symbol),
                'name': meta.get('longName') or meta.get('shortName', 'N/A'),
                'currency': meta.get('currency', 'USD'),
                'exchange': meta.get('exchangeName', 'N/A'),
                'current_price': current_price,
                'previous_close': previous_close,
                'open': opens[latest_idx] if opens and opens[latest_idx] else None,
                'high': highs[latest_idx] if highs and highs[latest_idx] else None,
                'low': lows[latest_idx] if lows and lows[latest_idx] else None,
                'volume': volumes[latest_idx] if volumes and volumes[latest_idx] else None,
                'market_cap': meta.get('marketCap'),
                'fifty_two_week_high': meta.get('fiftyTwoWeekHigh'),
                'fifty_two_week_low': meta.get('fiftyTwoWeekLow'),
                'timestamp': timestamps[latest_idx] if timestamps else None,
            }

            return True
        except (URLError, HTTPError, json.JSONDecodeError, KeyError, IndexError) as e:
            print(f"Error fetching data: {e}", file=sys.stderr)
            return False

    def _generate_ascii_art(self) -> None:
        
        if self.no_logo or not HAS_PIL:
            if not HAS_PIL and not self.no_logo:
                print("Note: PIL/Pillow not installed. Using fallback ASCII art.", file=sys.stderr)

            fallback_color = 'cyan' if not self.no_color else None
            self.ascii_art = ASCIIGenerator.get_fallback_ascii(self.symbol, fallback_color)
            return

        logo_data = LogoFetcher.fetch_logo(self.symbol, self.data.get('name', ''))

        if logo_data:
            ascii_lines = ASCIIGenerator.image_to_ascii_colored(
                logo_data,
                self.ascii_width,
                detailed=False,
                colored=self.colored_ascii
            )

            if ascii_lines:
                self.ascii_art = ascii_lines
                return

        fallback_color = 'cyan' if not self.no_color else None
        self.ascii_art = ASCIIGenerator.get_fallback_ascii(self.symbol, fallback_color)

    def _format_number(self, num: Optional[float], decimals: int = 2) -> str:
        
        if num is None:
            return "N/A"

        if abs(num) >= 1_000_000_000:
            return f"{num / 1_000_000_000:.{decimals}f}B"
        elif abs(num) >= 1_000_000:
            return f"{num / 1_000_000:.{decimals}f}M"
        elif abs(num) >= 1_000:
            return f"{num / 1_000:.{decimals}f}K"
        else:
            return f"{num:.{decimals}f}"

    def _format_price(self, price: Optional[float]) -> str:
        
        if price is None:
            return "N/A"
        currency_symbol = "$" if self.data['currency'] == "USD" else self.data['currency']
        return f"{currency_symbol}{price:.2f}"

    def _get_change_info(self) -> Tuple[float, float, str]:
        
        if not self.data:
            return 0.0, 0.0, 'white'

        current = self.data.get('current_price', 0)
        previous = self.data.get('previous_close', current)
        change = current - previous
        pct_change = (change / previous * 100) if previous else 0
        color = 'green' if change > 0 else 'red' if change < 0 else 'white'

        return change, pct_change, color

    def _strip_ansi(self, text: str) -> str:
        
        ansi_escape = re.compile(r'\033\[[0-9;]*m')
        return ansi_escape.sub('', text)

    def display(self) -> None:
        
        if not self._fetch_data() or not self.data:
            print(f"Error: Could not fetch data for symbol '{self.symbol}'", file=sys.stderr)
            sys.exit(1)

        self._generate_ascii_art()

        change, pct_change, change_color = self._get_change_info()
        change_symbol = "▲" if change > 0 else "▼" if change < 0 else "●"

        info_lines = [
            f"{self._colorize(self.data['symbol'], 'bold')}@{self._colorize(self.data['exchange'], 'bold')}",
            "─" * (len(self.data['symbol']) + len(self.data['exchange']) + 1),
            f"{self._colorize('Name:', 'cyan')} {self.data['name'][:50]}",
            f"{self._colorize('Price:', 'yellow')} {self._format_price(self.data['current_price'])}",
            f"{self._colorize('Change:', change_color)} {change_symbol} {self._format_price(abs(change))} ({abs(pct_change):.2f}%)",
            f"{self._colorize('Open:', 'blue')} {self._format_price(self.data['open'])}",
            f"{self._colorize('High:', 'green')} {self._format_price(self.data['high'])}",
            f"{self._colorize('Low:', 'red')} {self._format_price(self.data['low'])}",
            f"{self._colorize('Volume:', 'magenta')} {self._format_number(self.data['volume'], 1)}",
        ]

        if self.data.get('market_cap'):
            info_lines.append(
                f"{self._colorize('Market Cap:', 'cyan')} {self._format_number(self.data['market_cap'], 2)}"
            )

        if self.data.get('fifty_two_week_high'):
            info_lines.append(
                f"{self._colorize('52W High:', 'green')} {self._format_price(self.data['fifty_two_week_high'])}"
            )

        if self.data.get('fifty_two_week_low'):
            info_lines.append(
                f"{self._colorize('52W Low:', 'red')} {self._format_price(self.data['fifty_two_week_low'])}"
            )

        if self.data.get('timestamp'):
            dt = datetime.fromtimestamp(self.data['timestamp'])
            info_lines.append(f"{self._colorize('Updated:', 'white')} {dt.strftime('%Y-%m-%d %H:%M:%S')}")

        max_lines = max(len(self.ascii_art), len(info_lines))
        ascii_width = max(len(self._strip_ansi(line)) for line in self.ascii_art) if self.ascii_art else 0

        print()
        for i in range(max_lines):
            ascii_part = self.ascii_art[i] if i < len(self.ascii_art) else ""
            info_part = info_lines[i] if i < len(info_lines) else ""

            actual_width = len(self._strip_ansi(ascii_part))
            padding = " " * (ascii_width - actual_width + 4)
            print(f"{ascii_part}{padding}{info_part}")
        print()


def main():
    
    parser = argparse.ArgumentParser(
        description='stonkfetch - Display stock information with colored logo ASCII art',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
sfetch AAPL                       Display with colored logo
stonkfetch TSLA --no-color-ascii      Grayscale ASCII art
stonkfetch MSFT --no-logo             Use fallback ASCII
stonkfetch GOOGL --ascii-width 50     Custom width
stonkfetch AMZN --no-color            Disable all colors
        """
    
    )

    parser.add_argument(
        'symbol',
        type=str,
        help='Stock ticker symbol (e.g., AAPL, TSLA, MSFT)'
    )

    parser.add_argument(
        '--no-color',
        action='store_true',
        help='Disable all colored output (ASCII and text)'
    )

    parser.add_argument(
        '--no-color-ascii',
        action='store_true',
        help='Disable colors in ASCII art only (keep text colors)'
    )

    parser.add_argument(
        '--no-logo',
        action='store_true',
        help='Disable logo fetching and use fallback ASCII art'
    )

    parser.add_argument(
        '--ascii-width',
        type=int,
        default=40,
        help='Width of ASCII art in characters (default: 40)'
    )

    parser.add_argument(
        '--version',
        action='version',
        version='stonkfetch 1.0' 
    )

    args = parser.parse_args()

    colored_ascii = not args.no_color_ascii and not args.no_color

    fetcher = stonkfetch(
        args.symbol,
        no_color=args.no_color,
        no_logo=args.no_logo,
        ascii_width=args.ascii_width,
        colored_ascii=colored_ascii
    )

    fetcher.display()


if __name__ == "__main__":
    main()
